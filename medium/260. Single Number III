//136. Single Number 참고

// xor(^)은 비트연산으로 두 피연산자(비트)가 서로 다를 때(1 ^ 0, 0 ^ 1)일 때, xor하면 1을 리턴한다.
// 서로 다른 2 개의 수를 이진수로 표현시, 적어도 하나의 비트는 다를 것이다.
// xor은 같은 수를 xor하면 상쇄하는 성질이 있다.

// 2 개씩 있는 수들은 서로 상쇄되므로 모두 xor해서 나온 결과값은 1개만 있는 수 일 것이다.
// 결과값을 이진수로 표현하여 1인 자리수를 기준으로 2개의 그룹으로 나눈다.

// 3 = 0000 0011, 5 = 0000 0101
// 1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 = 0000 0110 = 3 ^ 5
// 어떤 비트든 하나의 비트를 골라 1인 수의 그룹과 0인 수의 그룹으로 나눠서 다시 xor해주고 나온 수를 return.


// <<   - 피 연산자의 비트열을 왼쪽(←)으로 이동. 이동에 따른 빈공간은 0으로 채움
// >>   - 피 연산자의 비트열을 오른쪽(→)으로 이동. 이동에 따른 빈공간은 양수일경우 0으로, 음수일경우 1으로 채움 
// >>> - 피 연산자의 비트열을 오른쪽(→)으로 이동. 이동에 따른 빈공간을 모두 0으로 채움   


    public int[] singleNumber(int[] nums) {
		
          		int xor = 0;
		   for(int num: nums) xor ^= num;
		   
		   int idx = 0;
		  	for(int i = 0 ; i < 32; i ++) {
			   if(((xor >> i) & 1 ) == 1) {
				   idx = i;
				  break; 
			   }
		   }
		   
           int num1 = 0;
		   int num2 = 0;
		   for(int num: nums) {
		   if(((num >> idx) & 1) == 1) {
			   num1 ^= num;
		   }else {
			   num2 ^= num;
		   }
		   }
		   
		   return new int[]{num1, num2};
	    }
